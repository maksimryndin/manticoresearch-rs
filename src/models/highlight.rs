/*
 * Manticore Search Client
 *
 * Ð¡lient for Manticore Search.
 *
 * The version of the OpenAPI document: 3.3.1
 * Contact: info@manticoresearch.com
 * Generated by: https://openapi-generator.tech
 */

/// Highlight : Query HIGHLIGHT expression

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Highlight {
    #[serde(rename = "fieldnames", skip_serializing_if = "Option::is_none")]
    pub fieldnames: Option<Vec<String>>,
    #[serde(rename = "fields", skip_serializing_if = "Option::is_none")]
    pub fields: Option<Vec<crate::models::HighlightField>>,
    #[serde(rename = "encoder", skip_serializing_if = "Option::is_none")]
    pub encoder: Option<Encoder>,
    #[serde(
        rename = "highlight_query",
        default,
        with = "::serde_with::rust::double_option",
        skip_serializing_if = "Option::is_none"
    )]
    pub highlight_query: Option<Option<::std::collections::HashMap<String, serde_json::Value>>>,
    #[serde(rename = "pre_tags", skip_serializing_if = "Option::is_none")]
    pub pre_tags: Option<String>,
    #[serde(rename = "post_tags", skip_serializing_if = "Option::is_none")]
    pub post_tags: Option<String>,
    #[serde(rename = "no_match_size", skip_serializing_if = "Option::is_none")]
    pub no_match_size: Option<NoMatchSize>,
    #[serde(rename = "fragment_size", skip_serializing_if = "Option::is_none")]
    pub fragment_size: Option<i32>,
    #[serde(
        rename = "number_of_fragments",
        skip_serializing_if = "Option::is_none"
    )]
    pub number_of_fragments: Option<i32>,
    #[serde(rename = "limit", skip_serializing_if = "Option::is_none")]
    pub limit: Option<i32>,
    #[serde(rename = "limit_words", skip_serializing_if = "Option::is_none")]
    pub limit_words: Option<i32>,
    #[serde(rename = "limit_snippets", skip_serializing_if = "Option::is_none")]
    pub limit_snippets: Option<i32>,
    #[serde(rename = "limits_per_field", skip_serializing_if = "Option::is_none")]
    pub limits_per_field: Option<bool>,
    #[serde(rename = "use_boundaries", skip_serializing_if = "Option::is_none")]
    pub use_boundaries: Option<bool>,
    #[serde(rename = "force_all_words", skip_serializing_if = "Option::is_none")]
    pub force_all_words: Option<bool>,
    #[serde(rename = "allow_empty", skip_serializing_if = "Option::is_none")]
    pub allow_empty: Option<bool>,
    #[serde(rename = "emit_zones", skip_serializing_if = "Option::is_none")]
    pub emit_zones: Option<bool>,
    #[serde(rename = "force_snippets", skip_serializing_if = "Option::is_none")]
    pub force_snippets: Option<bool>,
    #[serde(rename = "around", skip_serializing_if = "Option::is_none")]
    pub around: Option<i32>,
    #[serde(rename = "start_snippet_id", skip_serializing_if = "Option::is_none")]
    pub start_snippet_id: Option<i32>,
    #[serde(rename = "html_strip_mode", skip_serializing_if = "Option::is_none")]
    pub html_strip_mode: Option<HtmlStripMode>,
    #[serde(rename = "snippet_boundary", skip_serializing_if = "Option::is_none")]
    pub snippet_boundary: Option<SnippetBoundary>,
}

impl Highlight {
    /// Query HIGHLIGHT expression
    pub fn new() -> Highlight {
        Highlight {
            fieldnames: None,
            fields: None,
            encoder: None,
            highlight_query: None,
            pre_tags: None,
            post_tags: None,
            no_match_size: None,
            fragment_size: None,
            number_of_fragments: None,
            limit: None,
            limit_words: None,
            limit_snippets: None,
            limits_per_field: None,
            use_boundaries: None,
            force_all_words: None,
            allow_empty: None,
            emit_zones: None,
            force_snippets: None,
            around: None,
            start_snippet_id: None,
            html_strip_mode: None,
            snippet_boundary: None,
        }
    }
}

///
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Encoder {
    #[serde(rename = "default")]
    Default,
    #[serde(rename = "html")]
    Html,
}

impl Default for Encoder {
    fn default() -> Encoder {
        Self::Default
    }
}
///
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum NoMatchSize {
    #[serde(rename = "0")]
    Variant0,
    #[serde(rename = "1")]
    Variant1,
}

impl Default for NoMatchSize {
    fn default() -> NoMatchSize {
        Self::Variant0
    }
}
///
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum HtmlStripMode {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "strip")]
    Strip,
    #[serde(rename = "index")]
    Index,
    #[serde(rename = "retain")]
    Retain,
}

impl Default for HtmlStripMode {
    fn default() -> HtmlStripMode {
        Self::None
    }
}
///
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum SnippetBoundary {
    #[serde(rename = "sentence")]
    Sentence,
    #[serde(rename = "paragraph")]
    Paragraph,
    #[serde(rename = "zone")]
    Zone,
}

impl Default for SnippetBoundary {
    fn default() -> SnippetBoundary {
        Self::Sentence
    }
}
